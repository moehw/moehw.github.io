[ { "title": "Debugging PPC with PEmicro MultiLink", "url": "/posts/debugging-ppc-with-pemicro-multilink/", "categories": "howto", "tags": "debug, multilink, ppc", "date": "2021-12-13 07:03:49 +0000", "snippet": "Experience in debugging a device with a MPC5xxx from NXP (PPC architecture).It had approximately the following debug connector:And there was access to the PEmicro Multilink Universal. Software S32DS from NXP can work with it (to download it you can use creds from BugMeNot).But this IDE itself does not allow you to conveniently work for the purpose of debugging and dumping the firmware, so it is more convenient to take its individual plugins and work with them.If you have time and disk space, you can install the IDE itself and then use the plugins. This is a more reliable way. If there is no time, then you can follow this tutorial completely.Preparing for debuggingFor WindowsTested on a Windows 10 x64 virtual machine (VM).Drivers and plugins: here Attach PEMicro MultiLink. Throw it to the VM, if it is a VM. Unpack the archive. Copy PEMicro folder to C:\\ Open console as Administrator ( Win + X , release and then A ) Enter the following commands, agreeing to the installation:C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\wdreg_gui.exe -inf C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\pemicrowindrvr.inf -log C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\pe_winusb_interface.log install C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\wdreg_gui.exe -inf C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\pe_winusb_interface.inf -log C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\pe_winusb_interface.log install C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\wdreg_gui.exe -inf C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\osbdm\\pe_libusb_interface.inf -log C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\pe_winusb_interface.log install C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\wdreg_gui.exe -inf C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\osbdm\\serialcdc_interface.inf -log C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\pe_winusb_interface.log install cp -Path C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\windriver\\redist* -Destination C:\\Windows\\System32 cp -Path C:\\PEMicro\\PEDrivers\\supportfiles\\Drivers_12_7_0\\osbdm\\redist\\* -Destination C:\\Windows\\System32 Viewing the list of targets and selecting one of them (for example, MPC5606B):C:\\PEMicro\\com.pemicro.debug.gdbjtag.ppc_1.8.7.201906071634\\win32\\pegdbserver_power_console.exe -devicelist Enable target device. Launching the plugin (specifying the desired target):C:\\PEMicro\\com.pemicro.debug.gdbjtag.ppc_1.8.7.201906071634\\win32\\pegdbserver_power_console.exe -startserver -singlesession -useexternalip -device=MPC5606B After that, gdbserver should start:Connecting to gdbserverPort 7224 is used to connect to gdbserver (by default).You can connect from the host OS if everything is running in a VM with a network interface.Use: gdb-multiarch - some configuration required, but breakpoints work anyway gdb-powerpc-eabivle (from Release page or anywhere else)" }, { "title": "UDS protocol header file for RE", "url": "/posts/uds-header/", "categories": "howto", "tags": "automotive, rev", "date": "2021-11-30 18:22:07 +0000", "snippet": "TL;DRWhat I can contribute is this header file (to open it in IDA Pro and to use enums):uds.hIf you want to analyze exactly the part of the code with the processing of the UDS (a good attack vector), but there are no lines and logs, and, for example, the analysis of accesses to the memory area with the CAN (memory mapping) does not help… Then you can search for constant values in the code, that the most commonly implemented (may be ECU Reset (0x11) or response codes?), or that are visible in the sniffed traffic from/to the device.IntroUDS (Unified Diagnostic Services) is a diagnostic protocol that is often used in electronic control units (ECUs) within automotive electronics. The whole description of protocol, list of Service ID, response codes, etc. are described in ISO 14229. In my work, more often I came across the use of UDS over CAN, there was also DoIP, but there are other options. The working principle and structure (in pictures!) can be viewed at the link. To be honest, at the beginning I started to explain it by myself, but then I realize that another people do it very well :DExampleLet’s say there is some firmware where you want to find the part with UDS processing. Let’s open it in IDA Pro and try to find the immediate value 0x11 (ECU Reset and also serviceNotSupported values) through \"Search\" -&gt; \"Immediate value...\" (Alt + I).For some binary, I got a large list of instructions where this value is used, but the comparison instructions will be the most interesting places (in my case it’s PPC instructions).Not all cases found will suit me, but there should be some I need among them - so I go through them and look at the neighboring code.After a while, I managed to find several interesting places. The first is the place where the switch-case is used.By applying the enum UDS_sid from the header, there is more confidence that these are the handlers we need, which can be checked further when reversing.Do the same thing with a place suitable for serviceNotSupported.In enum UDS_sid_resp there are cases for 0x11, 0x12, 0x31 values. It becomes clear that this is some function for a negative answer:So I’ll just save that header here. It’s handy for use in situations like this :)" } ]
